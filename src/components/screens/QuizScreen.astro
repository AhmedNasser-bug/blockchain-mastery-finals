---

---

<div class="screen" id="quizScreen">
    <div class="card" style="margin-top:20px">
        <div class="timer-display" id="timer">00:00</div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar" style="width:0%"></div>
        </div>
        <div class="progress-text">
            <span id="currentQ">1</span> / <span id="totalQ">120</span> Questions
            <span style="margin-left:20px"
                >Score: <strong id="liveScore">0</strong></span
            >
        </div>
    </div>

    <div class="card question-container" id="questionContainer">
        <!-- Question content renders here -->
    </div>

    <div class="card" style="padding:15px">
        <div
            style="display:flex;justify-content:space-between;align-items:center"
        >
            <button
                class="btn btn-secondary"
                onclick="window.game.skipQuestion()"
            >
                Skip <span class="hot-key">S</span>
            </button>
            <div style="flex:1"></div>
            <button
                class="btn btn-secondary"
                id="hintBtn"
                onclick="window.game.showHint()"
                style="display:none; margin-right: 10px;"
            >
                ðŸ’¡ Hint
            </button>
            <button
                class="btn btn-primary"
                id="submitBtn"
                onclick="window.game.submitAnswer()"
                disabled
            >
                Submit <span class="hot-key">Enter</span>
            </button>
            <button
                onclick="window.game.showRevisionScreen()"
                class="glass-btn"
                id="revisionBtnQuiz"
                style="display:none"
            >
                <span class="icon">ðŸ“š</span> Full revision
            </button>
            <button
                class="btn btn-secondary"
                id="nextBtn"
                onclick="window.game.nextQuestion()"
                style="display:none"
            >
                Next <span class="hot-key">â†’</span>
            </button>
        </div>
    </div>
</div>

<script>
    import type {
        SubjectData as Subject,
        Question,
    } from "../../data/subjects/Subject";
    import { escapeHtml } from '../../utils';

    class QuizScreenController {
        private subject: Subject;
        private currentQuestions: Question[] = [];
        private currentIndex: number = 0;
        private score: number = 0;
        private streak: number = 0;
        private maxStreak: number = 0;
        private timer: any = null;
        private seconds: number = 0;
        private answers: any[] = [];
        private selectedOptions: any[] = [];
        private isAnswered: boolean = false;
        private config: any;

        constructor() {
            // @ts-ignore
            this.subject = window.subjectData;
            this.config = {
                TIMERS: {
                    BLITZ: { WARNING: 120, DANGER: 180 },
                    SPEEDRUN: { WARNING: 1200, DANGER: 1500 },
                },
                STREAK_MILESTONES: {
                    5: "ðŸ”¥ ON FIRE!",
                    10: "âš¡ UNSTOPPABLE!",
                    15: "ðŸ’Ž LEGENDARY!",
                    20: "ðŸ† GODLIKE!",
                    25: "ðŸŒŸ TRANSCENDENT!",
                },
            };
            this.bindEvents();
        }

        bindEvents() {
            // @ts-ignore
            window.game = window.game || {};
            // @ts-ignore
            window.game.startQuiz = this.startQuiz.bind(this);
            // @ts-ignore
            window.game.submitAnswer = this.submitAnswer.bind(this);
            // @ts-ignore
            window.game.nextQuestion = this.nextQuestion.bind(this);
            // @ts-ignore
            window.game.skipQuestion = this.skipQuestion.bind(this);
            // @ts-ignore
            window.game.showHint = this.showHint.bind(this);
            // @ts-ignore
            window.game.selectMCQ = this.selectOption.bind(this);
            // @ts-ignore
            window.game.selectMulti = this.selectMulti.bind(this);
            // @ts-ignore
            window.game.selectTF = this.selectTF.bind(this);
            // @ts-ignore
            window.game.selectTF = this.selectTF.bind(this);
            
            document.addEventListener('keydown', this.handleKeydown.bind(this));
        }

        handleKeydown(e: KeyboardEvent) {
             const screen = document.getElementById('quizScreen');
             if (!screen?.classList.contains('active')) return;

             const key = e.key.toLowerCase();

             // 1. Navigation / Action
             if (key === 'enter') {
                 if (this.isAnswered) {
                     this.nextQuestion();
                 } else {
                     this.submitAnswer();
                 }
                 return;
             }

             if (key === 's') {
                 this.skipQuestion();
                 return;
             }

             // 2. Selection (Numbers 1-9)
             if (/^[1-9]$/.test(key)) {
                 const idx = parseInt(key) - 1;
                 const q = this.currentQuestions[this.currentIndex];
                 if(idx >= (q.options?.length || 0)) return;

                 if (q.type === 'mcq') this.selectOption(idx);
                 else if (q.type === 'multi') this.selectMulti(idx);
                 return;
             }
            
             // 3. Selection (Letters a-z) - Optional mapping A->0, B->1...
             // (Skipping for now to keep it simple, or can add if requested)
             
             // 4. TF Selection
             if (key === 't') this.selectTF(true);
             if (key === 'f') this.selectTF(false);
        }

        startQuiz() {
            // @ts-ignore
            const homeController = window.game; // Assuming home controller is mixed into window.game or similar
            // In the unified Game.ts pattern, state was shared. Here we need to grab it from somewhere or passed in.
            // TEMPORARY FIX: We access the DOM elements directly to see selected mode since they are separate controllers now.

            const modeBtn = document.querySelector(
                ".mode-btn.selected",
            ) as HTMLElement;
            const currentMode = modeBtn ? modeBtn.dataset.mode : "speedrun";

            // Logic to get questions based on mode
            if (currentMode === "practice") {
                // We need to find the selected category
                const catCard = document.querySelector(
                    '.category-card[style*="var(--primary)"]',
                );
                if (!catCard) {
                    alert("Please select a category first!");
                    return;
                }
                const category = catCard.querySelector("h3")?.textContent;
                this.currentQuestions = this.shuffleArray(
                    this.subject.questions.filter(
                        (q) => q.category === category,
                    ),
                );
            } else if (currentMode === "blitz") {
                // Dynamic Blitz: 30 or 25% of total, whichever is smaller (but min 10 if possible)
                // Actually user said "Subject specific", implies using the config or just "not fixed".
                // Let's default to a "Smart Blitz" - 25% of the deck to ensure rotation.
                // Or if there's a config in subjectData, use that (TODO: Add config schema later)
                const blitzCount = Math.max(10, Math.floor(this.subject.questions.length * 0.25));
                this.currentQuestions = this.shuffleArray(
                    this.subject.questions,
                ).slice(0, blitzCount);
            } else if (currentMode === "hardcore") {
                this.currentQuestions = this.shuffleArray(
                    this.subject.questions.filter(
                        (q) => q.category === "Hardcore",
                    ),
                );
            } else if (currentMode === "full-revision") {
                // 1. Get ordered questions (No Shuffle)
                const orderedQuestions = [...this.subject.questions];
                
                // 2. Convert Terminology to Questions
                const termQuestions: any[] = Object.entries(this.subject.terminology).map(([term, data], idx) => ({
                    id: `term_${idx}`,
                    type: 'tf', // Using True/False template
                    category: 'Terminology',
                    // ESCAPE the dynamic content inside, but mark question as HTML so <strong> etc. works
                    question: `<strong>Term:</strong> ${escapeHtml(term.replace(/_/g, ' '))}<br><br><strong>Definition:</strong> ${escapeHtml(data.Meaning)}<br><br>Is this definition correct?`,
                    correct: true,
                    explanation: `<strong>Analogy:</strong> ${escapeHtml(data.Analogy || 'N/A')}`,
                    difficulty: 'easy',
                    isHtml: true // Flag as pre-formatted
                }));

                // 3. Combine
                this.currentQuestions = [...orderedQuestions, ...termQuestions];
            } else {
                // Speedrun: ALL Questions (Time Attack)
                this.currentQuestions = this.shuffleArray(
                    this.subject.questions,
                ); 
                // Removed .slice(0, 120) limit
            }

            this.currentIndex = 0;
            this.score = 0;
            this.streak = 0;
            this.maxStreak = 0;
            this.seconds = 0;
            this.answers = [];

            const totalEl = document.getElementById("totalQ");
            if (totalEl)
                totalEl.textContent = this.currentQuestions.length.toString();

            this.showScreen("quizScreen");
            this.startTimer(currentMode || "speedrun");
            this.renderQuestion();
        }

        private showScreen(id: string) {
            document
                .querySelectorAll(".screen")
                .forEach((s) => s.classList.remove("active"));
            document.getElementById(id)?.classList.add("active");
        }

        private startTimer(mode: string) {
            if (this.timer) clearInterval(this.timer);
            this.timer = setInterval(() => {
                this.seconds++;
                const display = document.getElementById("timer");
                if (display) 
                {
                    display.textContent = this.formatTime(this.seconds);
                    display.classList.remove("warning", "danger");

                    const limits = (mode === "blitz") ? this.config.TIMERS.BLITZ : this.config.TIMERS.SPEEDRUN;


                    if (this.seconds > limits.DANGER){
                        display.classList.add("danger");
                    }
                    else if (this.seconds > limits.WARNING){
                        display.classList.add("warning");
                    }
                }
            }, 1000);
        }

        stopTimer() {
            if (this.timer) clearInterval(this.timer);
        }

        renderQuestion() {
            const q = this.currentQuestions[this.currentIndex];
            const container = document.getElementById("questionContainer");
            if (!container || !q) return;

            this.selectedOptions = [];
            this.isAnswered = false;

            // Update progress
            const currentQ = document.getElementById("currentQ");
            if (currentQ)
                currentQ.textContent = (this.currentIndex + 1).toString();

            const progressBar = document.getElementById("progressBar");
            if (progressBar) {
                const progress =
                    (this.currentIndex / this.currentQuestions.length) * 100;
                progressBar.style.width = progress + "%";
            }

            const hintBtn = document.getElementById("hintBtn");
            if (hintBtn)
                hintBtn.style.display =
                    q.relatedTerms && q.relatedTerms.length > 0
                        ? "inline-flex"
                        : "none";

            // Render question content
            container.innerHTML = this.buildQuestionHTML(q);
            container.classList.remove("shake", "celebrate");

            // Reset buttons
            const submitBtn = document.getElementById(
                "submitBtn",
            ) as HTMLButtonElement;
            if (submitBtn) {
                submitBtn.style.display = "inline-flex";
                submitBtn.disabled = true;
            }
            const nextBtn = document.getElementById("nextBtn");
            if (nextBtn) nextBtn.style.display = "none";
        }

        private buildQuestionHTML(q: Question): string {
            const LETTERS = ["A", "B", "C", "D", "E", "F"];

            // Logic: If q.isHtml is true, assume safe HTML (use as-is). 
            // If false/undefined (default JSON), allow NO HTML (escape everything).
            const safeQuestion = q.isHtml ? q.question : escapeHtml(q.question);

            let html = `
                <div class="question-header">
                    <span class="question-number">Question ${this.currentIndex + 1} of ${this.currentQuestions.length}</span>
                    <span class="question-category">${q.category}</span>
                </div>
                <div class="question-text">${safeQuestion}</div>
            `;

            if (q.type === "mcq" && q.options) {
                html += `<div class="options-grid">${q.options
                    .map(
                        (opt, idx) => `
                    <div class="option" onclick="window.game.selectMCQ(${idx})" data-idx="${idx}">
                        <span class="option-marker">${LETTERS[idx]}</span>
                        <span class="option-text">${escapeHtml(opt)}</span>
                    </div>
                `,
                    )
                    .join("")}</div>`;
            } else if (q.type === "multi" && q.options) {
                 html += `
                    <div class="instruction-text" style="color:var(--text-secondary);margin-bottom:10px;font-size:0.9rem">
                        (Select all that apply)
                    </div>
                    <div class="options-grid">
                    ${q.options
                    .map(
                        (opt, idx) => `
                    <div class="option multi-option" onclick="window.game.selectMulti(${idx})" data-idx="${idx}">
                        <div class="checkbox-indicator"></div>
                        <span class="option-text">${escapeHtml(opt)}</span>
                    </div>
                `,
                    )
                    .join("")}</div>`;
            } else if (q.type === "tf") {
                html += `
                    <div class="tf-grid">
                        <div class="option tf-option" onclick="window.game.selectTF(true)" data-value="true">
                            <span class="option-marker">âœ“</span>
                            <span class="option-text">TRUE</span>
                        </div>
                        <div class="option tf-option" onclick="window.game.selectTF(false)" data-value="false">
                            <span class="option-marker">âœ—</span>
                            <span class="option-text">FALSE</span>
                        </div>
                    </div>
                `;
            }

            html += '<div class="feedback" id="feedback"></div>';
            return html;
        }

        selectOption(idx: number) {
            if (this.isAnswered) return;
            document
                .querySelectorAll(".option")
                .forEach((opt) => opt.classList.remove("selected"));
            document
                .querySelector(`.option[data-idx="${idx}"]`)
                ?.classList.add("selected");
            this.selectedOptions = [idx];

            const btn = document.getElementById(
                "submitBtn",
            ) as HTMLButtonElement;
            if (btn) btn.disabled = false;
        }



        selectMulti(idx: number) {
            if (this.isAnswered) return;
            
            const optEl = document.querySelector(`.option[data-idx="${idx}"]`);
            if (optEl) {
                optEl.classList.toggle("selected");
            }

            if (this.selectedOptions.includes(idx)) {
                this.selectedOptions = this.selectedOptions.filter(i => i !== idx);
            } else {
                this.selectedOptions.push(idx);
            }
            // Sort for comparison
            this.selectedOptions.sort((a, b) => a - b);


            const btn = document.getElementById(
                "submitBtn",
            ) as HTMLButtonElement;
            if (btn) btn.disabled = this.selectedOptions.length === 0;
        }

        selectTF(value: boolean) {
            if (this.isAnswered) return;
            document
                .querySelectorAll(".tf-option")
                .forEach((opt) => opt.classList.remove("selected"));
            document
                .querySelector(`.tf-option[data-value="${value}"]`)
                ?.classList.add("selected");
            this.selectedOptions = [value];

            const btn = document.getElementById(
                "submitBtn",
            ) as HTMLButtonElement;
            if (btn) btn.disabled = false;
        }

        submitAnswer() {
            if (this.isAnswered || this.selectedOptions.length === 0)
                return false;

            this.isAnswered = true;
            const q = this.currentQuestions[this.currentIndex];
            let isCorrect = false;

            if (q.type === "mcq") {
                isCorrect = this.selectedOptions[0] === q.correct;
                this.highlightOptions(q.correct as number);
            } else if (q.type === "tf") {
                isCorrect = this.selectedOptions[0] === q.correct;
                this.highlightTF(q.correct as boolean);
            } else if (q.type === "multi") {
                // Array comparison
                const correctArr = (q.correct as number[]).sort((a, b) => a - b);
                isCorrect = JSON.stringify(this.selectedOptions) === JSON.stringify(correctArr);
                this.highlightMulti(correctArr);
            }

            this.answers.push({
                question: q.question,
                correct: isCorrect,
                userAnswer: this.selectedOptions,
                correctAnswer: q.correct,
                explanation: q.explanation,
            });

            const feedback = document.getElementById("feedback");
            const container = document.getElementById("questionContainer");

            // Handle Explanation Safe Rendering
            const safeExplanation = q.isHtml ? q.explanation : escapeHtml(q.explanation);

            if (isCorrect) {
                this.score++;
                this.streak++;
                if (this.streak > this.maxStreak) this.maxStreak = this.streak;
                if (feedback && container) {
                    feedback.className = "feedback correct";
                    feedback.innerHTML = `<span class="feedback-icon">âœ“</span> Correct! ${safeExplanation}`;
                    container.classList.add("celebrate");
                    this.checkCombo();
                }
            } else {
                this.streak = 0;
                if (feedback && container) {
                    feedback.className = "feedback incorrect";
                    feedback.innerHTML = `<span class="feedback-icon">âœ—</span> Incorrect. ${safeExplanation}`;
                    container.classList.add("shake");
                }
            }

            // Update UI
            const liveScore = document.getElementById("liveScore");
            if (liveScore) liveScore.textContent = this.score.toString();

            const submitBtn = document.getElementById("submitBtn");
            if (submitBtn) submitBtn.style.display = "none";

            const nextBtn = document.getElementById("nextBtn");
            if (nextBtn) nextBtn.style.display = "inline-flex";

            return isCorrect;
        }

        highlightOptions(correctIdx: number) {
            document.querySelectorAll(".option").forEach((opt: any) => {
                const idx = parseInt(opt.dataset.idx);
                if (idx === correctIdx) {
                    opt.classList.add("correct");
                } else if (opt.classList.contains("selected")) {
                    opt.classList.add("incorrect");
                }
            });
        }

        highlightTF(correctVal: boolean) {
            document.querySelectorAll(".tf-option").forEach((opt: any) => {
                const val = opt.dataset.value === "true";
                if (val === correctVal) {
                    opt.classList.add("correct");
                } else if (opt.classList.contains("selected")) {
                    opt.classList.add("incorrect");
                }
            });
        }

        highlightMulti(correctArr: number[]) {
             document.querySelectorAll(".multi-option").forEach((opt: any) => {
                const idx = parseInt(opt.dataset.idx);
                const isSelected = opt.classList.contains("selected");
                const isCorrect = correctArr.includes(idx);

                if (isCorrect) {
                     opt.classList.add("correct");
                     // Ensure checkmark shows
                     opt.innerHTML += '<span style="margin-left:auto;color:var(--success)">âœ“</span>';
                } else if (isSelected && !isCorrect) {
                    opt.classList.add("incorrect");
                }
            });
        }

        nextQuestion() {
            this.currentIndex++;
            if (this.currentIndex < this.currentQuestions.length) {
                this.renderQuestion();
                return true;
            } else {
                this.finishQuiz();
                return false;
            }
        }

        skipQuestion() {
            const q = this.currentQuestions[this.currentIndex];
            this.answers.push({
                question: q.question,
                correct: false,
                userAnswer: null,
                correctAnswer: q.correct,
                explanation: q.explanation,
            });
            this.streak = 0;
            this.nextQuestion();
        }

        showHint() {
            const q = this.currentQuestions[this.currentIndex];
            if (q.relatedTerms && q.relatedTerms.length > 0) {
                alert(`Related Terms: ${q.relatedTerms.join(", ")}`);
            } else {
                alert("No specific hint for this question.");
            }
        }

        finishQuiz() {
            this.stopTimer();
            const results = {
                score: this.score,
                total: this.currentQuestions.length,
                time: this.seconds,
                answers: this.answers,
                maxStreak: this.maxStreak,
            };

            // @ts-ignore
            if (window.game.showResults) {
                // @ts-ignore
                window.game.showResults(results);
            }
        }

        private formatTime(secs: number): string {
            const m = Math.floor(secs / 60);
            const s = secs % 60;
            return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
        }

        private shuffleArray(array: any[]) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        checkCombo() {
            if (this.config.STREAK_MILESTONES[this.streak]) {
                const popup = document.getElementById("comboPopup");
                const text = document.getElementById("comboText");
                if (popup && text) {
                    text.textContent =
                        this.config.STREAK_MILESTONES[this.streak];
                    popup.classList.add("active");
                    popup.style.display = "block";
                    setTimeout(() => {
                        popup.classList.remove("active");
                        popup.style.display = "none";
                    }, 2000);
                }
            }
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        new QuizScreenController();
    });
</script>
