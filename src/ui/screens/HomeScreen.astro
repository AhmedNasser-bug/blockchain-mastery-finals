---
import SetupPanel from "../components/modules/SetupPanel.astro";
import ModeSelector from "../components/modules/ModeSelector.astro";
import OperationLogs from "../components/modules/OperationLogs.astro";
import '../../styles/screens/home.css';
interface Props {
    subjectName: string;
    description: string;
}
const { subjectName, description } = Astro.props;
---

<div class="screen active" id="homeScreen">
    <div style="max-width: 1200px; margin: 0 auto; padding: 40px;">
        <div class="header">
            <h1 class="hero-title">{subjectName.toUpperCase()}</h1>
             <div class="hero-subtitle-container">
                <div class="separator-line"></div>
                <p class="subtitle-text">MASTERY PROTOCOL V2</p>
            </div>
            <p class="description-text">{description}</p>
        </div>

        {/* Setup Module */}
        <SetupPanel />

        <div class="card selector-container">
            <h2 class="section-title">SELECT OPERATIONAL MODE</h2>
            
            {/* New Mode Selector Component */}
            <ModeSelector onSelect={(mode) => console.log('Mode selected', mode)} />

            <div id="categorySelector" class="category-selector-container">
                <h3 class="category-selector-title">TARGET SECTOR</h3>
                <div class="category-grid" id="categoryGrid"></div>
            </div>

            <div class="start-btn-group">
                <button
                    class="btn btn-secondary encyclopedia-btn"
                    id="revisionBtn"
                >
                    üìñ ENCYCLOPEDIA (REF)
                </button>
                <button
                    class="btn btn-primary start-challenge-btn"
                    onclick="window.game.startQuiz()"
                >
                    INITIALIZE CHALLENGE
                </button>
            </div>
        </div>

        <div class="card history-card">
            <div class="history-header">
                <h2>OPERATION LOGS</h2>
            </div>
            <OperationLogs />
        </div>
    </div>
</div>

<!-- Settings Panel Overlay -->




<script>
    import type { SubjectData as Subject } from "../../data/subjects/Subject";
    import { SUBJECT_MODES } from "../../data/subjects/Subject";

    class HomeScreenController {
        private subject: Subject;
        private currentMode: string = "speedrun";
        private selectedCategory: string | null = null;
        private settingsPanel: any; // Instance of GameSettingsPanel

        constructor() {
            // @ts-ignore
            this.subject = window.subjectData;
            this.bindEvents();
            this.init();
        }

        bindEvents() {
            // Bind global methods for legacy/inline calls if any (though we prefer listeners)
            // @ts-ignore
            window.game = window.game || {};
            // @ts-ignore
            window.game.startQuiz = this.startChallenge.bind(this);
            // @ts-ignore
            window.game.selectMode = this.selectMode.bind(this);
            // @ts-ignore
            window.game.selectCategory = this.selectCategory.bind(this);
            // @ts-ignore
            window.game.updateStats = this.updateStats.bind(this);
            // @ts-ignore
            window.game.loadHistory = this.loadHistory.bind(this);
            // @ts-ignore
            window.game.goHome = this.goHome.bind(this);
            // @ts-ignore
            window.game.showRevisionScreen = () => {
                 this.currentMode = 'full-revision'; // Just a fallback
                 // We need to implement actual screen switching if 'RevisionScreen' is a separate component
                 document.getElementById('homeScreen')?.classList.remove('active');
                 document.getElementById('revisionScreen')?.classList.add('active');
            };

            // Attach explicit listeners for robustness
            // We listen to the Custom Event dispatched by ModeSelector component
            document.addEventListener('mode-selected', (e: any) => {
                 if(e.detail) {
                     this.selectMode(e.detail);
                 }
            });
            
            document.getElementById('revisionBtn')?.addEventListener('click', () => {
                 // @ts-ignore
                 window.game.showRevisionScreen();
            });
        }

        goHome() {
            document
                .querySelectorAll(".screen")
                .forEach((s) => s.classList.remove("active"));
            document.getElementById("homeScreen")?.classList.add("active");
            this.updateStats();
            this.loadHistory();
        }

        startChallenge() {
            // Read config from SetupPanel
            const config = (window as any).getGameConfig ? (window as any).getGameConfig() : { isSurvival: false, timeLimitSeconds: 0 };
            
            // Store config globally or pass it? 
            // For transition, we'll attach it to the game object so specific screens can read it
            // until we fully refactor them to use GameEngine directly.
            (window as any).currentGameConfig = config;

            // @ts-ignore
            const game = window.game;

            // Simple "Launch" for now as requested "Prepare interface", maybe not enforce it yet?
            // User: "Prepare the interface of each mode for a settings pattern refactor"
            // I will Launch directly for now to preserve existing behavior, 
            // BUT I will modify this to support a "Setup Phase".
            
            // Let's just Launch the Mode. The Settings Panel exists in DOM now.
            // Wiring it up completely might break "Quick Start" if user didn't ask for mandatory settings.
            
            switch(this.currentMode) {
                case 'speedrun':
                    if(game.startSpeedrun) game.startSpeedrun();
                    break;
                case 'blitz':
                    if(game.startBlitz) game.startBlitz();
                    break;
                case 'hardcore':
                    if(game.startHardcore) game.startHardcore();
                    break;
                case 'full-revision':
                    if(game.startExam) game.startExam();
                    break;
                case 'practice':
                    if(game.startPractice) game.startPractice(this.selectedCategory);
                    break;
                case 'flashcards':
                    // Legacy fallback
                    if(game.startFlashcards) game.startFlashcards('questionBank');
                    break;
                case 'terminology':
                    if(game.startFlashcards) game.startFlashcards('terminology');
                    break;
                case 'question-bank':
                    if(game.startFlashcards) game.startFlashcards('questionBank');
                    break;
                default:
                    console.warn("Unknown mode:", this.currentMode);
            }
        }

        init() {
            this.updateStats();
            this.loadHistory();
            this.renderCategories();
        }

        selectMode(mode: string) {
            this.currentMode = mode;
            // Visual state handled by ModeSelector component
            
            const categorySelector =
                document.getElementById("categorySelector");
            if (categorySelector) {
                categorySelector.style.display =
                    mode === "practice" ? "block" : "none";
            }
        }

        selectCategory(category: string) {
            this.selectedCategory = category;
            document.querySelectorAll(".category-card").forEach((card: any) => {
                const title = card.querySelector("h3")?.textContent;
                // @ts-ignore
                card.style.borderColor =
                    title === category ? "var(--primary)" : "var(--border)";
                // @ts-ignore
                card.style.background =
                    title === category
                        ? "rgba(255, 215, 0, 0.1)"
                        : "var(--bg-card)";
            });
        }

        private updateStats() {
            const data = this.loadProgress();

            const elRuns = document.getElementById("totalRuns");
            if (elRuns) elRuns.textContent = data.runs.length.toString();

            const elBestScore = document.getElementById("bestScore");
            if (elBestScore) elBestScore.textContent = data.bestScore + "%";

            const elBestStreak = document.getElementById("bestStreak");
            if (elBestStreak)
                elBestStreak.textContent = data.bestStreak.toString();

            if (data.runs.length > 0) {
                const avg = Math.round(
                    data.runs.reduce((a: number, b: any) => a + b.score, 0) /
                        data.runs.length,
                );
                const elAvg = document.getElementById("avgScore");
                if (elAvg) elAvg.textContent = avg + "%";
            }

            const awardCount = data.achievements ? data.achievements.length : 0;
            const totalAwards = this.subject.achievements?.length || 0;
            const awardEl = document.getElementById("totalAwards");
            if (awardEl)
                awardEl.textContent = `üèÜ ${awardCount}/${totalAwards}`;
        }

        private loadHistory() {
            const data = this.loadProgress();
            const container = document.getElementById("historyContainer");
            if (!container) return;

            if (data.runs.length === 0) {
                container.innerHTML =
                    '<p class="empty-history">No runs yet. Start your first challenge!</p>';
                return;
            }

            const recentRuns = data.runs.slice(-10).reverse();
            let html =
                '<table class="history-table"><thead><tr><th>Date</th><th>Mode</th><th>Score</th><th>Time</th><th>Grade</th></tr></thead><tbody>';

            recentRuns.forEach((run: any) => {
                const grade = this.getGrade(run.score);
                const badgeClass =
                    run.score >= 87
                        ? "badge-success"
                        : run.score >= 70
                          ? "badge-warning"
                          : "badge-error";
                html += `<tr><td>${new Date(run.date).toLocaleDateString()}</td><td style="text-transform:capitalize">${run.mode}</td><td><strong>${run.score}%</strong></td><td>${this.formatTime(run.time)}</td><td><span class="badge ${badgeClass}">${grade}</span></td></tr>`;
            });

            html += "</tbody></table>";
            container.innerHTML = html;
        }

        private renderCategories() {
            const grid = document.getElementById("categoryGrid");
            if (!grid) return;

            const categories = [
                ...new Set(this.subject.questions.map((q) => q.category)),
            ];
            grid.innerHTML = categories
                .map((cat) => {
                    const count = this.subject.questions.filter(
                        (q) => q.category === cat,
                    ).length;
                    return `<div class="category-card" data-cat="${cat}" onclick="window.game.selectCategory('${cat}')"><h3>${cat}</h3><span>${count} questions</span></div>`;
                })
                .join("");
        }

        private loadProgress(): any {
            // @ts-ignore
            if (!this.subject.config)
                return { runs: [], bestScore: 0, bestStreak: 0 };
            const saved = localStorage.getItem(
                this.subject.config.storageKey || this.subject.id,
            );
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error(e);
                }
            }
            return { runs: [], bestScore: 0, bestStreak: 0 };
        }

        private getGrade(score: number): string {
            if (score >= 97) return "S+";
            if (score >= 93) return "S";
            if (score >= 90) return "A+";
            if (score >= 87) return "A";
            if (score >= 80) return "B+";
            if (score >= 70) return "C+";
            if (score >= 60) return "D+";
            return "F";
        }

        private formatTime(secs: number): string {
            const m = Math.floor(secs / 60);
            const s = secs % 60;
            return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        new HomeScreenController();
    });
</script>
