---
import GameHeader from '../../components/GameHeader.astro';
import QuestionContainer from '../../components/gameplay/QuestionContainer.astro';
import GameFooter from '../../components/GameFooter.astro';
import HintPopup from '../../components/HintPopup.astro';
import StreakCounter from '../../components/modules/StreakCounter.astro';
import '../../../styles/screens/speedrun.css';
---

<div class="screen speedrun-screen" id="speedrun-screen">
    <div class="screen-wrapper">
        <GameHeader mode="challenge" id="sr-header" />
        
        <div class="sr-content">
            <!-- Question Container wraps Display + StressBar logic -->
            <QuestionContainer id="sr-question-container" enableStressBar={true} />
        </div>
    
        <GameFooter id="sr-footer" />
        <HintPopup id="sr-hint-popup" />
        
        <!-- Module: Streak Counter -->
        <StreakCounter id="sr-streak" />
    </div>
</div>

<script>
    import { GameEngine } from "../../../logic/controllers/GameEngine";
    import { Subject } from "../../../logic/entities/Subject";
    import { Player } from "../../../logic/entities/Player";

    class ChallengeGameController {
        private engine: GameEngine;
        private header: any;
        private footer: any;
        private container: any;
        private streakModule: any;
        
        private isAnswered: boolean = false;
        private currentSelection: any = null;
        private config: any = {};

        constructor() {
            // Wait for DOM to be fully ready and components to mount
            window.addEventListener('load', () => this.tryInit());
        }

        async tryInit() {
             const screen = document.getElementById('speedrun-screen');
             if(!screen) return;

             // Poll for dependencies (max 1 second)
             let attempts = 0;
             const interval = setInterval(() => {
                 this.header = (document.getElementById('sr-header') as any)?.headerInstance;
                 this.footer = (document.getElementById('sr-footer') as any)?.footerInstance;
                 this.container = (document.getElementById('sr-question-container') as any)?.containerInstance;
                 this.streakModule = (document.getElementById('sr-streak') as any)?.streakInstance;

                 // We need at least Header, Footer, and Container
                 if (this.header && this.footer && this.container) {
                     clearInterval(interval);
                     this.init(screen);
                 } else {
                     attempts++;
                     if (attempts > 20) { // 2 seconds timeout
                         console.error("Critical: Failed to load Game Components", { 
                             h: !!this.header, f: !!this.footer, c: !!this.container 
                         });
                         clearInterval(interval);
                         // Try init anyway, maybe partial
                         this.init(screen);
                     }
                 }
             }, 100);
        }

        init(screen: HTMLElement) {
            console.log("Game Controller: Components Linked");
            this.bindEvents(screen);
            this.registerGlobal();
        }
        
        bindEvents(screen: HTMLElement) {
            // Screen specific event bubbling
            screen.addEventListener('request-submit', () => this.submitAnswer());
            screen.addEventListener('request-next', () => this.nextQuestion());
            screen.addEventListener('request-skip', () => this.handleSkip());
            screen.addEventListener('question-selected', (e: any) => this.handleSelection(e.detail));
            
            // Timer Events
            screen.addEventListener('time-up', (e: any) => this.handleTimeEvent(e));
        }

        registerGlobal() {
            // @ts-ignore
            window.game = window.game || {};
            // @ts-ignore
            window.game.startSpeedrun = this.startChallenge.bind(this);
            // @ts-ignore
            window.game.startBlitz = this.startChallenge.bind(this);
            // @ts-ignore
            window.game.startHardcore = this.startChallenge.bind(this);
            // @ts-ignore
            window.game.startExam = this.startChallenge.bind(this);
        }

        async startChallenge() {
            this.activateScreen();
            
            // 1. Config
            // @ts-ignore
            this.config = (window as any).getGameConfig ? (window as any).getGameConfig() : { isSurvival: false, timeLimitSeconds: 0 };
            console.log("Starting Config:", this.config);
            
            // 2. Data
            // @ts-ignore
            const subjectData = window.subjectData;
            const subject = new Subject(
                subjectData.id, 
                subjectData.name
            );
            // ENFORCE OFFLINE-FIRST: Load only from DB
            await subject.loadFromDB();
            
            const player = await Player.create("Guest");  

            // 3. Engine
            this.engine = new GameEngine(
                subject, player,
                { subjectId: subject.id, modeType: 'challenge', settings: this.config },
                (state) => this.renderState(state)
            );
            
            // 4. Start Game
            await this.engine.start();
            
            // 5. Start Header Timer (Total)
            if(this.header) {
                this.header.startTimer(this.config.timeLimitSeconds || 0);
            }
        }

        activateScreen() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('speedrun-screen')?.classList.add('active');
        }

        renderState(state: any) {
            if(state.isGameOver) return this.finishGame(state);
            
            this.isAnswered = false;
            this.currentSelection = null;
            
            // 1. Render Question
            if(this.container) {
                this.container.render(state.currentQuestion);
                this.container.enableStressBar(this.config.isSurvival);
                if(this.config.isSurvival) {
                    this.container.startStressTimer(15); // Per question
                } else {
                    this.container.stopStressTimer();
                }
            }

            // 2. Update Header
            if(this.header) this.header.setScore(state.score);
            
            // 3. Streak Feedback (Every 5)
            if (state.streak > 0 && state.streak % 5 === 0 && !this.isAnswered) {
                // Prevent duplicate showing if state re-renders? 
                // Engine renders on 'nextQuestion' usually.
                // We might want to show this after Answer, not on render of new question?
                // Actually internal render is called after answer submission too.
                if(this.streakModule) this.streakModule.show(state.streak);
            }

            // 4. Update Footer
            if(this.footer) {
                this.footer.showSubmit();
                this.footer.enableSubmit(false);
            }
        }
        
        handleSelection(detail: any) {
            if (this.isAnswered) return;
            this.currentSelection = detail;
            if(this.footer) this.footer.enableSubmit(true);
        }

        submitAnswer() {
            console.log("ChallengeController: submitAnswer called", { 
                isAnswered: this.isAnswered, 
                hasSelection: !!this.currentSelection 
            });
            if (this.isAnswered || !this.currentSelection) {
                console.warn("ChallengeController: Submit ignored", { isAnswered: this.isAnswered, selection: this.currentSelection });
                return;
            }
            this.isAnswered = true;
            this.processResult();
        }

        handleSkip() {
             if(this.isAnswered) return;
             this.currentSelection = null; // No selection = incorrect/skip
             this.isAnswered = true;
             this.engine.submitAnswer(false); // Count as wrong? Or Engine needs 'skip' method?
             // Assuming wrong for now
             if(this.container) {
                 this.container.stopStressTimer();
                 this.container.showFeedback(false);
                 this.container.reveal();
             }
             if(this.footer) this.footer.showNext("Next");
        }

        processResult() {
             if(this.container) {
                 this.container.stopStressTimer();
                 const isCorrect = this.container.reveal();
                 this.container.showFeedback(isCorrect);
                 this.engine.submitAnswer(isCorrect);
             }
             if(this.footer) this.footer.showNext();
        }

        nextQuestion() {
            // Engine auto-advances? No, we manually get next from engine?
            // Engine typically advances on submit? 
            // Wait, existing GameEngine calls `renderState` implicitly?
            // If Engine auto-calls renderState after submit, we don't need to do anything but wait.
            // BUT, usually we want a "Review" state (UI waits). 
            // So we trigger engine.next()? 
            // Let's assume Engine needs a trigger if it's not auto. 
            // Actually, existing Engine implementation (seen in other files) usually calls callback immediately.
            // If we want a 'Pause', the Engine shouldn't auto-advance.
            // Checking GameEngine.ts (not visible now, but based on past context), it likely advances immediately.
            // If it advances immediately, we might be rendering the NEXT question already?
            // We need to decouple rendering.
            
            // For now, let's assume Engine has `nextQuestion()` method or we just re-render?
            // Actually, standard practice: submit -> result -> callback(nextQuestion). 
            // If render is called immediately, the user sees next question immediately.
            // We want to see Feedback first. 
            // So RenderState should differentiate 'Feedback State' vs 'Question State'?
            // Simplest hack: The engine.submitAnswer is called. It updates score. It fetches next question. It calls render.
            // We can block the render if we want? 
            // Better: Engine.next() should be separate.
            
            // I'll assume standard Engine behaves: submit -> result -> callback(nextQuestion).
            // To pause, we can store the 'nextState' and only apply it when nextQuestion() is called.
            // But let's stick to simple implementation first.
             this.engine.nextQuestion(); // Assuming this exists or is needed.
        }

        handleTimeEvent(e: any) {
            // Differentiate local vs global
            // QuestionContainer (Local Stress) vs header (Global Stopwatch)
            
            // Component structure: 
            // Header -> Stopwatch
            // Container -> StressBarwrapper -> StressBar
            
            // We can check e.target ID or class
            const targetId = (e.target as HTMLElement).id;
            
            if(targetId.includes('stopwatch')) {
                // Global Time Up
                 console.log("Game Over: Time Limit");
                 this.finishGame(this.engine.getState());
            } else {
                // Local Stress Bar
                console.log("Question Time Limit");
                this.handleSkip(); 
                // Show feedback "Time's Up"
                // Then show Next button
            }
        }
        
        finishGame(state: any) {
             if(this.header) this.header.stopTimer();
             if(this.container) this.container.stopStressTimer();
             
             // @ts-ignore
             if (window.game.showResults) {
                // @ts-ignore
                window.game.showResults({
                    score: state.correctCount,
                    total: state.totalQuestions,
                    time: 0, // Get from stopwatch?
                    answers: [],
                    maxStreak: state.maxStreak,
                    mode: 'challenge'
                });
             }
        }
    }

    new ChallengeGameController();
</script>
