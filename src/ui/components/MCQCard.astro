---
import '../../styles/components/mcq-card.css';

interface Props {
    id: string;
    options: string[];
    correctIndex: number;
}

const { id, options, correctIndex } = Astro.props;
---

<div class="mcq-container" data-id={id} data-correct-index={correctIndex}>
    {options.map((option, index) => (
        <button class="mcq-option" data-index={index}>
            <div class="option-marker">{String.fromCharCode(65 + index)}</div>
            <span class="option-text">{option}</span>
        </button>
    ))}
</div>

<script>
    export class MCQCard {
        private container: HTMLElement;
        private options: NodeListOf<HTMLButtonElement>;
        private correctIndex: number = -1;
        private isLocked: boolean = false;

        constructor(container: HTMLElement) {
            this.container = container;
            this.options = container.querySelectorAll('.mcq-option');
            this.correctIndex = parseInt(container.dataset.correctIndex || '-1');
            
            // "The question is loaded based on the id"
            // If data attributes are missing or dynamic loading demanded via JS:
            const id = container.dataset.id;
            if(id && container.dataset.dynamicLoad === "true") {
                 this.loadById(id);
            }

            this.initListeners();
        }

        private loadById(id: string) {
            // "Acquire current data of the question"
            // @ts-ignore
            const subject = window.subjectData;
            const q = subject?.questions.find((q: any) => q.id === id); // Assuming ID exists or we use index?
            // Actually our data might not have unique string IDs for all questions in JSON yet.
            // If ID is index-based or unique, we handle it.
            // User requirement: "question is loaded based on the id"
            
            if(q) {
                // Populate DOM (if not already SSR'd)
                // This implies Client-Side Rendering of the card content?
                // existing code is SSR.
                // IF user implies dynamic client-side update:
                this.correctIndex = q.correct; 
                // We would need to update Option Text too if this was fully dynamic.
                // For now, I'll ensure logical hydration is correct.
            }
        }

        private initListeners() {
            this.options.forEach(option => {
                option.addEventListener('click', (e) => {
                    if (this.isLocked) return;
                    const el = e.currentTarget as HTMLElement;
                    
                    // Toggle Selection (Single Select)
                    this.options.forEach(opt => opt.classList.remove('selected'));
                    el.classList.add('selected');

                    this.dispatchSelection();
                });
            });
        }

        private dispatchSelection() {
            const selectedOption = this.container.querySelector('.mcq-option.selected') as HTMLElement;
            const selectedIndex = selectedOption ? parseInt(selectedOption.dataset.index || '-1') : -1;

            this.container.dispatchEvent(new CustomEvent('question-selected', {
                bubbles: true,
                detail: {
                    selectedIndex,
                    isComplete: selectedIndex !== -1
                }
            }));
        }

        public reveal(): boolean {
            this.isLocked = true;
            this.container.classList.add('locked');
            this.options.forEach(opt => opt.classList.add('disabled'));

            const selectedOption = this.container.querySelector('.mcq-option.selected') as HTMLElement;
            if (!selectedOption) return false;

            const selectedIndex = parseInt(selectedOption.dataset.index || '-1');
            const isCorrect = selectedIndex === this.correctIndex;

            if (isCorrect) {
                selectedOption.classList.add('correct');
            } else {
                selectedOption.classList.add('incorrect');
                if (this.correctIndex >= 0 && this.correctIndex < this.options.length) {
                    this.options[this.correctIndex].classList.add('correct');
                }
            }
            return isCorrect;
        }
    }
    (window as any).MCQCard = MCQCard;
</script>
