---
// QuestionDisplay.astro
// Acts as a dynamic host for specific Question Cards via QuestionContainer
import QuestionContainer from './gameplay/QuestionContainer.astro';
import '../../styles/components/question-cards.css'; // RESTORED STYLES

interface Props {
  id?: string;
}

const { id = "questionDisplay" } = Astro.props;
---

<div class="question-display-root" id={id}>
    <div class="q-header-meta">
       <span class="category-badge" id="qdCategory">Category</span>
       <!-- Difficulty could go here -->
    </div>

    <div class="q-text-area" id="qdText">
        Loading Question...
    </div>

    <!-- Container for dynamic card injection -->
    <div class="q-card-area" id="qdCardArea">
        <!-- Dynmaically mounted cards go here -->
    </div>
    
    <div class="q-feedback-area hidden" id="qdFeedback">
        <div class="feedback-content" id="qdExplanation"></div>
    </div>
</div>

<style>
    .question-display-root {
        padding: 0;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 100%;
        max-width: 900px; /* Constrained width */
        margin: 0 auto;
    }

    .q-header-meta {
        display: flex;
        justify-content: flex-end;
    }

    .category-badge {
        font-family: 'Roboto Condensed', sans-serif;
        text-transform: uppercase;
        color: var(--primary);
        font-weight: 700;
        letter-spacing: 1px;
        font-size: 0.9rem;
        background: rgba(255, 215, 0, 0.1);
        padding: 4px 12px;
        border-radius: 4px;
    }

    .q-text-area {
        position: relative;
        background: transparent;
        border: none;
        padding: 20px;
        font-size: clamp(1.1rem, 2.5vw, 1.5rem);
        line-height: 1.3;
        font-weight: 700;
        flex-grow: 1; 
        flex-shrink: 1;
        min-height: 100px; 
        max-height: 40vh;
        overflow-y: auto;
        color: var(--text-primary);
        font-family: 'Roboto Condensed', sans-serif;
        text-transform: uppercase;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        background-image: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, transparent 100%);
    }

    .q-text-area::before {
        content: '"';
        position: absolute;
        top: -10px;
        left: 20px;
        font-size: 4rem;
        line-height: 1;
        color: var(--primary);
        opacity: 0.2;
        font-family: serif;
    }

    .q-feedback-area {
        background: var(--bg-card);
        border: 2px solid var(--border);
        padding: 20px;
        margin-top: 20px;
        animation: slideIn 0.3s ease;
    }
    
    .q-feedback-area.correct {
        border-color: var(--success);
        background: rgba(34, 197, 94, 0.1);
        color: var(--success);
    }
    
    .q-feedback-area.incorrect {
        border-color: var(--error);
        background: rgba(239, 68, 68, 0.1);
        color: var(--error);
    }

    .hidden {
        display: none !important;
    }

    @keyframes slideIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
</style>

<script>
    // We import Card Classes. 
    // In a full refactor, these would be exported from the .astro files or separate .ts files.
    // Assuming global availability for now as per existng pattern or we could dynamic import.
    
    export class QuestionDisplay {
        private container: HTMLElement;
        private categoryEl: HTMLElement;
        private textEl: HTMLElement;
        private cardArea: HTMLElement;
        private feedbackEl: HTMLElement;
        private explanationEl: HTMLElement;
        
        private activeComponent: any = null;
        private currentQuestion: any = null;
        
        private header: any;
        private footer: any;

        constructor(container: HTMLElement) {
            this.container = container;
            this.categoryEl = container.querySelector('#qdCategory')!;
            this.textEl = container.querySelector('#qdText')!;
            this.cardArea = container.querySelector('#qdCardArea')!;
            this.feedbackEl = container.querySelector('#qdFeedback')!;
            this.explanationEl = container.querySelector('#qdExplanation')!;
            
            this.findDependencies();
        }

        private findDependencies() {
            const screen = this.container.closest('.screen') || document.body;
            const headerEl = screen.querySelector('.game-header');
            const footerEl = screen.querySelector('.game-footer');
            
            if(headerEl) this.header = (headerEl as any).gameHeaderInstance;
            if(footerEl) this.footer = (footerEl as any).gameFooterInstance;
            
            if(!this.header || !this.footer) {
                // Retry simply helper
                setTimeout(() => this.findDependencies(), 100);
            } else {
                this.initOrchestration();
            }
        }
        
        private initOrchestration() {
            window.addEventListener('request-submit', () => this.handleSubmit());
        }

        public render(question: any) {
            this.currentQuestion = question;
            if(!question) return;

            // Update UI
            this.categoryEl.textContent = question.category || 'General';
            this.feedbackEl.classList.add('hidden');
            this.feedbackEl.className = 'q-feedback-area hidden'; // Reset classes
            
            this.textEl.textContent = ''; // Safer than innerHTML for clear
            const textContent = document.createElement('div');
            textContent.className = 'q-text-content';
            textContent.textContent = question.question; // Use textContent for safety
            // If question has HTML needs (e.g. code blocks), we might need innerHTML but sanitized.
             this.textEl.innerHTML = question.question;

            // Clear Area
            this.cardArea.innerHTML = '';
            this.activeComponent = null;

            // Render Card Safely
            this.mountCard(question);
            
            // Hint Logic ...
            this.updateHint(question);
        }
        
        private mountCard(question: any) {
             let containerClass = '';
             let cardClass: any = null;
             
             if (question.type === 'tf') {
                 containerClass = 'tf-container';
                 cardClass = (window as any).TFCard;
             } else if (question.type === 'mmcq' || question.type === 'multi') {
                 containerClass = 'mmcq-container';
                 cardClass = (window as any).MMCQCard;
             } else {
                 containerClass = 'mcq-container';
                 cardClass = (window as any).MCQCard;
             }
             
             // Create container programmatically
             const wrapper = document.createElement('div');
             wrapper.className = containerClass;
             wrapper.dataset.id = question.id;
             wrapper.dataset.correct = JSON.stringify(question.correct); // Data attr for Card logic
             
             // Pre-fill HTML structure required by the Legacy Card Classes?
             wrapper.innerHTML = this.generateCardSkeleton(question); // This is still HTML gen, but localized.
             
             this.cardArea.appendChild(wrapper);
             
             this.cardArea.appendChild(wrapper);
             
             if(cardClass) {
                 this.activeComponent = new cardClass(wrapper);
             }

             // Event Delegation for Options
             // This ensures we catch clicks on buttons generated by generateCardSkeleton
             wrapper.addEventListener('click', (e) => this.handleOptionClick(e));
        }

        private handleOptionClick(e: Event) {
            const target = (e.target as HTMLElement).closest('button');
            if (!target) return;

            // Handle selection UI
            this.container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            target.classList.add('selected');

            // Dispatch Event to Controller
            // Data-index or Data-value needed
            const detail = {
                index: target.dataset.index,
                value: target.dataset.value
            };
            
            // Inform Card Class if needed (for internal state)
            if (this.activeComponent && typeof this.activeComponent.select === 'function') {
                this.activeComponent.select(detail.index || detail.value);
            }

            // Bubble up to Screen
            const event = new CustomEvent('question-selected', { 
                bubbles: true, 
                detail: detail 
            });
            this.container.dispatchEvent(event);
        }
        
        // Helper to keep render() clean
        private generateCardSkeleton(question: any): string {
             if (question.type === 'tf') {
                 return `
                    <button class="tf-option true-option" data-value="true"><span class="tf-icon">üëç</span> True</button>
                    <button class="tf-option false-option" data-value="false"><span class="tf-icon">üëé</span> False</button>
                 `;
             } else if (question.type === 'mmcq' || question.type === 'multi') {
                 return `
                    <div class="mmcq-instruction">Select all that apply</div>
                    ${question.options.map((opt: string, i: number) => `
                        <button class="mmcq-option" data-index="${i}"><div class="checkbox-indicator"></div><span>${opt}</span></button>
                    `).join('')}
                 `;
             } else {
                 // MCQ
                  return question.options.map((opt: string, i: number) => `
                        <button class="mcq-option" data-index="${i}">
                             <div class="option-marker">${String.fromCharCode(65 + i)}</div>
                             <span class="option-text">${opt}</span>
                        </button>
                    `).join('');
             }
        }
        
        private updateHint(question: any) {
             if(this.footer) {
                 this.footer.setCurrentHint(question.hint || "");
             }
        }
        
        private handleSubmit() {
             if (this.activeComponent && typeof this.activeComponent.reveal === 'function') {
                const isCorrect = this.activeComponent.reveal();
                this.handleResult(isCorrect);
            }
        }
        
        private handleResult(isCorrect: boolean) {
            import('../scripts/GameUtils').then(({ GameUtils }) => {
                 GameUtils.recordAnswer(isCorrect);
            });
            this.showFeedback(isCorrect, this.currentQuestion.explanation);
        }

        public showFeedback(isCorrect: boolean, explanation: string) {
            this.feedbackEl.classList.remove('hidden');
            this.feedbackEl.classList.add(isCorrect ? 'correct' : 'incorrect');
            const icon = isCorrect ? 'üéâ Correct!' : '‚ùå Incorrect';
            this.explanationEl.innerHTML = `<strong>${icon}</strong><br/>${explanation}`;
        }
    }

    (window as any).QuestionDisplay = QuestionDisplay;

    document.querySelectorAll('.question-display-root').forEach(el => {
        (el as any).questionDisplayInstance = new QuestionDisplay(el as HTMLElement);
    });
</script>
