{
  "Cryptography": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The practice of securing communication and data from adversaries using mathematical techniques.",
    "Where_it_is_used": "Throughout the entire blockchain stack, from wallet creation to transaction signing and block hashing.",
    "When_it_is_used": "Whenever data needs to be kept secret (encryption), authentic (signatures), or tamper-evident (hashing).",
    "Analogy": "Like writing a letter in a secret code that only your friend can read, or sealing it in an envelope that reveals if it was opened.",
    "Pros": [
      "Ensures data integrity and confidentiality",
      "Enables trustless systems"
    ],
    "Cons": [
      "Can be computationally intensive",
      "Key management is difficult for users"
    ]
  },
  "Public_Key_Cryptography_(Asymmetric_Cryptography)": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A cryptographic system that uses pairs of keys: public keys (which may be disseminated widely) and private keys (which are known only to the owner).",
    "Where_it_is_used": "Wallet creation, transaction signing, and SSL/TLS web security.",
    "When_it_is_used": "To generate a user's address and to prove ownership of funds without revealing the secret key.",
    "Analogy": "Like a mailbox: anyone can drop a letter in (encrypt with public key/send to address), but only you have the key to open it (decrypt with private key/sign to spend).",
    "Pros": [
      "Enables secure communication without shared secrets",
      "Provides digital signatures"
    ],
    "Cons": [
      "Slower than symmetric cryptography",
      "If private key is lost, access is lost forever"
    ]
  },
  "Public_Key": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A cryptographic code that allows a user to receive cryptocurrencies; it is derived from the private key and can be shared publicly.",
    "Where_it_is_used": "Account addresses, receiving funds.",
    "When_it_is_used": "When you want someone to send you assets or to verify a signature you created.",
    "Analogy": "Like your bank account number or email addressâ€”safe to share so people can send you things.",
    "Pros": [
      "Safe to share publicly",
      "Enables receipt of funds"
    ],
    "Cons": [
      "Privacy risk if associated with real-world identity"
    ]
  },
  "Private_Key": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A secret number that allows cryptocurrency to be spent or proves ownership of an asset.",
    "Where_it_is_used": "Digital wallets, signing transactions.",
    "When_it_is_used": "When you initiate a transaction or want to decrypt a message sent to you.",
    "Analogy": "Like the PIN to your bank card or the physical key to your safe. Never share it.",
    "Pros": [
      "Complete control over assets",
      "No intermediary needed"
    ],
    "Cons": [
      "Irreversible loss of funds if lost",
      "High security risk if stolen"
    ]
  },
  "Digital_Signature": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A mathematical scheme for verifying the authenticity of digital messages or documents.",
    "Where_it_is_used": "Every blockchain transaction.",
    "When_it_is_used": "To prove that a transaction was created by the owner of the private key without revealing the key itself.",
    "Analogy": "Like a wax seal on a letter that proves it came from the King and hasn't been altered.",
    "Pros": [
      "Non-repudiation (signer can't deny it)",
      "Tamper-proof"
    ],
    "Cons": [
      "Requires secure key management"
    ]
  },
  "Hash_Function": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A function that converts an input (or 'message') into a fixed-size string of bytes, typically a digest that is unique to each unique input.",
    "Where_it_is_used": "Block linking, address generation, Merkle trees, mining (PoW).",
    "When_it_is_used": "To verify data integrity or compress data into a unique identifier.",
    "Analogy": "Like a fingerprint: a person is large and complex, but their fingerprint is small, unique, and identifies them reliably.",
    "Pros": [
      "Deterministic",
      "Fast computation",
      "Avalanche effect (tiny change = huge output diff)"
    ],
    "Cons": [
      "One-way (cannot retrieve original data)",
      "Collision attacks (theoretical risk)"
    ]
  },
  "Hash_(Cryptographic_Digest)": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The fixed-length output string generated by a hash function.",
    "Where_it_is_used": "Tx IDs, Block IDs, Merkle roots.",
    "When_it_is_used": "To refer to a specific block or transaction uniquely.",
    "Analogy": "The digital fingerprint itself.",
    "Pros": [
      "Unique identifier",
      "Compact representation"
    ],
    "Cons": [
      "None specific (it's a result)"
    ]
  },
  "Hashing": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The process of applying a hash function to data.",
    "Where_it_is_used": "Mining, data verification.",
    "When_it_is_used": "Continuously in PoW mining, or when verifying a file's integrity.",
    "Analogy": "The act of taking the fingerprint.",
    "Pros": [
      "Secure verification",
      "Data compression for IDs"
    ],
    "Cons": [
      "Energy intensive in PoW context"
    ]
  },
  "Merkle_Tree": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A tree structure in which every leaf node is a hash of a data block, and every non-leaf node is a hash of its children.",
    "Where_it_is_used": "Inside block headers to summarize all transactions.",
    "When_it_is_used": "To allow efficient and secure verification of content in large bodies of data.",
    "Analogy": "Like a tournament bracket where the winner (Root) represents all the matches played below.",
    "Pros": [
      "Efficient verification (SPV)",
      "Data integrity checking"
    ],
    "Cons": [
      "Complexity to implement"
    ]
  },
  "Merkle_Root": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The single hash at the top of a Merkle Tree that uniquely represents all the data in the tree.",
    "Where_it_is_used": "Block header.",
    "When_it_is_used": "To ensure that no transaction in the block has been altered; if one bit changes, the root changes.",
    "Analogy": "The 'Seal of Authenticity' on the tournament bracket.",
    "Pros": [
      "Compact proof of integrity for thousands of items"
    ],
    "Cons": [
      "If lost, cannot verify the set"
    ]
  },
  "Merkle_Proof": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A path of hashes from a specific leaf up to the Merkle Root, used to prove that a leaf exists in the tree.",
    "Where_it_is_used": "Light clients (SPV), Layer 2 rollups.",
    "When_it_is_used": "To verify a transaction was included in a block without downloading the whole block.",
    "Analogy": "Showing just the path of matches your team won to prove they reached the finals, without showing every other game in the tournament.",
    "Pros": [
      "Privacy (selective disclosure)",
      "Bandwidth efficiency"
    ],
    "Cons": [
      "Requires access to the full tree to generate"
    ]
  },
  "Elliptic_Curve_Cryptography_(ECC)": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A key-based technique for encrypting data or creating digital signatures using the mathematics of elliptic curves.",
    "Where_it_is_used": "Bitcoin (secp256k1), Ethereum, most modern chains.",
    "When_it_is_used": "Generating keys and signing transactions.",
    "Analogy": "A very complex math problem that is easy to create but impossible to solve backwards, used to make keys.",
    "Pros": [
      "Smaller key sizes than RSA for same security",
      "Fast"
    ],
    "Cons": [
      "Complex mathematics",
      "Vulnerable to quantum computing"
    ]
  },
  "Zero-Knowledge_Proof_(ZKP)": {
    "Category": "Cryptographic Primitives",
    "Meaning": "A method by which one party can prove to another that they know a value, without conveying any information apart from the fact that they know the value.",
    "Where_it_is_used": "Privacy coins (Zcash), Scalability (ZK-Rollups).",
    "When_it_is_used": "To prove you have funds or passed KYC without revealing your balance or identity.",
    "Analogy": "Walking into a cave and coming out the other side to prove you have the secret password to the door inside, without saying the password.",
    "Pros": [
      "Privacy",
      "Scalability (validity proofs)"
    ],
    "Cons": [
      "Computationally heavy generation",
      "Newer/complex tech"
    ]
  },
  "Encryption": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The process of encoding information so only authorized parties can access it.",
    "Where_it_is_used": "Wallet files, P2P communication channels (not typically transaction data on public chains).",
    "When_it_is_used": "To protect secrets at rest or in transit.",
    "Analogy": "Putting a message in a locked box.",
    "Pros": [
      "Confidentiality",
      "Security"
    ],
    "Cons": [
      "If key is lost, data is unrecoverable"
    ]
  },
  "Decryption": {
    "Category": "Cryptographic Primitives",
    "Meaning": "The process of converting encrypted data back into its original form.",
    "Where_it_is_used": "Opening a wallet, reading a secure message.",
    "When_it_is_used": "When the authorized user wants to access their data.",
    "Analogy": "Unlocking the box.",
    "Pros": [
      "Access to data"
    ],
    "Cons": [
      "Requires the key"
    ]
  },
  "Distributed_Ledger": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "A database valid and consistent across multiple locations or participants.",
    "Where_it_is_used": "The foundation of blockchain technology.",
    "When_it_is_used": "To remove the need for a central authority.",
    "Analogy": "A Google Doc where everyone has edit access, but changes are only saved if everyone votes 'yes'.",
    "Pros": [
      "No single point of failure",
      "Transparency"
    ],
    "Cons": [
      "Slower than centralized databases"
    ]
  },
  "Ledger": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "A book or collection of financial accounts of a particular type.",
    "Where_it_is_used": "Accounting, Banking, Blockchain.",
    "When_it_is_used": "To track ownership and history of value transfers.",
    "Analogy": "The record book.",
    "Pros": [
      "History of truth"
    ],
    "Cons": [
      "Garbage in, garbage out (unless validated)"
    ]
  },
  "Transaction": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "An agreement between a buyer and seller to exchange goods, services, or assets.",
    "Where_it_is_used": "The atomic unit of blockchain activity.",
    "When_it_is_used": "Sending money, executing code.",
    "Analogy": "Writing a check.",
    "Pros": [
      "Transfer of value"
    ],
    "Cons": [
      "Fees",
      "Latency"
    ]
  },
  "Block": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "A container structure that holds a batch of valid transactions.",
    "Where_it_is_used": "The structural unit of the blockchain time-chain.",
    "When_it_is_used": "Confirmed every ~10 mins (BTC) or ~12s (ETH).",
    "Analogy": "A page in the ledger book.",
    "Pros": [
      "Orders transactions",
      "Provides discrete update steps"
    ],
    "Cons": [
      "Size limits throughput"
    ]
  },
  "Block_Header": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "Metadata about the block (version, prev hash, merkle root, timestamp, etc.).",
    "Where_it_is_used": "Mining, Light Clients.",
    "When_it_is_used": "To link blocks and verify validity without downloading full data.",
    "Analogy": "The title and page number at the top of the page.",
    "Pros": [
      "Lightweight verification"
    ],
    "Cons": [
      "None"
    ]
  },
  "Previous_Block_Hash": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "A reference to the hash of the immediately preceding block.",
    "Where_it_is_used": "In every Block Header.",
    "When_it_is_used": "To create the 'chain' in blockchain.",
    "Analogy": "Glue sticking this page to the previous one.",
    "Pros": [
      "Ensures chronological order",
      "Prevents tampering with history"
    ],
    "Cons": [
      "None"
    ]
  },
  "Block_Hash": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "The unique identifier of a block, generated by hashing its header.",
    "Where_it_is_used": "To identify blocks.",
    "When_it_is_used": "Mining competitions, linking the next block.",
    "Analogy": "The page number (but cryptographically unique).",
    "Pros": [
      "Uniqueness",
      "Integrity"
    ],
    "Cons": [
      "None"
    ]
  },
  "Timestamp": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "Data field proving that a block was created at a specific time.",
    "Where_it_is_used": "Block header, difficulty adjustment.",
    "When_it_is_used": "To prevent manipulation of block times and difficulty.",
    "Analogy": "Date stamp on a letter.",
    "Pros": [
      "Temporal ordering"
    ],
    "Cons": [
      "Can be slightly manipulated by miners (within limits)"
    ]
  },
  "Nonce": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "A 'number used once' added to a hashed block that, when rehashed, meets the difficulty level restrictions.",
    "Where_it_is_used": "Proof of Work Mining.",
    "When_it_is_used": "Miners change this value millions of times a second to find a valid block hash.",
    "Analogy": "The winning lottery ticket number.",
    "Pros": [
      "Enables PoW lottery"
    ],
    "Cons": [
      "None"
    ]
  },
  "Genesis_Block": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "The first block of a blockchain.",
    "Where_it_is_used": "The start of the chain (Block 0).",
    "When_it_is_used": "At the launch of the network.",
    "Analogy": "Page 1 of the history book.",
    "Pros": [
      "Anchors the chain",
      "Sets initial distribution"
    ],
    "Cons": [
      "Usually centralized creation"
    ]
  },
  "Immutability": {
    "Category": "Data Model & Ledger Structure",
    "Meaning": "The ability of a blockchain ledger to remain unchanged, for an unaltered history of transactions.",
    "Where_it_is_used": "Core value proposition of blockchain.",
    "When_it_is_used": "When auditability and censorship resistance are required.",
    "Analogy": "Writing in stone vs writing in pencil.",
    "Pros": [
      "Trust",
      "Auditability"
    ],
    "Cons": [
      "Mistakes cannot be fixed easily"
    ]
  },
  "Node": {
    "Category": "Network Architecture",
    "Meaning": "Any computer that connects to the blockchain network.",
    "Where_it_is_used": "Everywhere in the P2P network.",
    "When_it_is_used": "To maintain the network map and relay data.",
    "Analogy": "A server or phone running the app.",
    "Pros": [
      "Redundancy"
    ],
    "Cons": [
      "Resource usage"
    ]
  },
  "Peer-to-Peer_(P2P)_Network": {
    "Category": "Network Architecture",
    "Meaning": "A distributed network architecture where participants share a part of the workload.",
    "Where_it_is_used": "File sharing (BitTorrent), Blockchain.",
    "When_it_is_used": "To avoid a central server bottleneck or point of control.",
    "Analogy": "A conversation circle vs a lecture hall.",
    "Pros": [
      "Censorship resistance",
      "Scalability (read)"
    ],
    "Cons": [
      "Scalability (write/propagation speed)"
    ]
  },
  "Full_Node": {
    "Category": "Network Architecture",
    "Meaning": "A program that fully validates transactions and blocks.",
    "Where_it_is_used": "Backbone of network security.",
    "When_it_is_used": "To independently verify the state without trusting anyone.",
    "Analogy": "An auditor checking every receipt.",
    "Pros": [
      "Maximum security",
      "Truestlessness"
    ],
    "Cons": [
      "High storage/bandwidth"
    ]
  },
  "Light_Node_(SPV)": {
    "Category": "Network Architecture",
    "Meaning": "Simplified Payment Verification user.",
    "Where_it_is_used": "Mobile wallets.",
    "When_it_is_used": "To verify payments without downloading the whole chain.",
    "Analogy": "Reading the executive summary.",
    "Pros": [
      "Fast",
      "Low storage"
    ],
    "Cons": [
      "Trusts full nodes for data availability"
    ]
  },
  "Archive_Node": {
    "Category": "Network Architecture",
    "Meaning": "A node storing the entire history of the blockchain state.",
    "Where_it_is_used": "Block explorers, analytics.",
    "When_it_is_used": "Querying ancient data.",
    "Analogy": "The national library archives.",
    "Pros": [
      "Historical data access"
    ],
    "Cons": [
      "Massive storage cost"
    ]
  },
  "Miner_Node": {
    "Category": "Network Architecture",
    "Meaning": "A node that performs Proof of Work to create new blocks.",
    "Where_it_is_used": "Bitcoin, PoW chains.",
    "When_it_is_used": "To secure the network and mint new coins.",
    "Analogy": "Gold prospector.",
    "Pros": [
      "Secures network",
      "Minting rewards"
    ],
    "Cons": [
      "Energy intensive"
    ]
  },
  "Validator_Node": {
    "Category": "Network Architecture",
    "Meaning": "A node responsible for verifying transactions and blocks (often in PoS).",
    "Where_it_is_used": "PoS chains (Ethereum, Solana).",
    "When_it_is_used": "Voting on block validity.",
    "Analogy": "A board member voting on decisions.",
    "Pros": [
      "Energy efficient"
    ],
    "Cons": [
      "Stake capital required"
    ]
  },
  "Relay_Node": {
    "Category": "Network Architecture",
    "Meaning": "A node that creates communication channels between nodes.",
    "Where_it_is_used": "Lightning Network, general P2P gossip.",
    "When_it_is_used": "Optimizing data propagation.",
    "Analogy": "A repeater tower.",
    "Pros": [
      "Speed",
      "Privacy"
    ],
    "Cons": [
      "No consensus role usually"
    ]
  },
  "Consensus_Mechanism": {
    "Category": "Consensus & Economics",
    "Meaning": "Fault-tolerant mechanism used in computer and blockchain systems to achieve the necessary agreement on a single data value or a single state of the network.",
    "Where_it_is_used": "The core logic of the blockchain.",
    "When_it_is_used": "To agree on the order of transactions.",
    "Analogy": "A group vote to decide where to go for lunch.",
    "Pros": [
      "Agreement in distributed systems"
    ],
    "Cons": [
      "Latency"
    ]
  },
  "Proof_of_Work_(PoW)": {
    "Category": "Consensus & Economics",
    "Meaning": "One party proves to others that a certain amount of computational effort has been expended.",
    "Where_it_is_used": "Bitcoin.",
    "When_it_is_used": "To prevent sybil attacks and determine the next block author.",
    "Analogy": "Sudoku: hard to solve, easy to check.",
    "Pros": [
      "Proven security",
      "Objective truth"
    ],
    "Cons": [
      "Energy waste",
      "Slow"
    ]
  },
  "Proof_of_Stake_(PoS)": {
    "Category": "Consensus & Economics",
    "Meaning": "Concept states that a person can validate block transactions according to how many coins they hold.",
    "Where_it_is_used": "Ethereum.",
    "When_it_is_used": "Alternative to PoW for energy efficiency.",
    "Analogy": "Shareholder voting.",
    "Pros": [
      "Energy efficient",
      "Fast"
    ],
    "Cons": [
      "Rich get richer",
      "Complexity"
    ]
  },
  "Delegated_Proof_of_Stake_(DPoS)": {
    "Category": "Consensus & Economics",
    "Meaning": "Token holders vote for a few delegates to secure the network.",
    "Where_it_is_used": "EOS, TRON.",
    "When_it_is_used": "To achieve high speed.",
    "Analogy": "Representative democracy (Congress).",
    "Pros": [
      "Very fast",
      "Scalable"
    ],
    "Cons": [
      "Centralization risk",
      "Voter apathy"
    ]
  },
  "Byzantine_Fault_Tolerance_(BFT)": {
    "Category": "Consensus & Economics",
    "Meaning": "The dependability of a fault-tolerant computer system, particularly, where the component may fail and there is imperfect information on whether a component is failed.",
    "Where_it_is_used": "Theoretical basis of consensus.",
    "When_it_is_used": "Designing systems that survive malicious nodes.",
    "Analogy": "Generals agreeing to attack a city when some messengers are traitors.",
    "Pros": [
      "Robustness"
    ],
    "Cons": [
      "Communication overhead"
    ]
  },
  "Practical_Byzantine_Fault_Tolerance_(PBFT)": {
    "Category": "Consensus & Economics",
    "Meaning": "An algorithm optimization that enables BFT to work in asynchronous systems with low latency.",
    "Where_it_is_used": "Permissioned chains (Hyperledger), Tendermint.",
    "When_it_is_used": "For fast finality with known validator sets.",
    "Analogy": "A highly organized committee vote.",
    "Pros": [
      "Fast finality"
    ],
    "Cons": [
      "Does not scale to thousands of nodes well"
    ]
  },
  "Federated_Byzantine_Agreement_(FBA)": {
    "Category": "Consensus & Economics",
    "Meaning": "A form of BFT where each node chooses its own slice of trust.",
    "Where_it_is_used": "Stellar, Ripple.",
    "When_it_is_used": "Open membership without PoW.",
    "Analogy": "Web of trust.",
    "Pros": [
      "Flexible",
      "Low energy"
    ],
    "Cons": [
      "Complex topology analysis"
    ]
  },
  "Synchronous_Consensus": {
    "Category": "Consensus & Economics",
    "Meaning": "Consensus depending on messages being delivered within a fixed time.",
    "Where_it_is_used": "Traditional distributed DBs.",
    "When_it_is_used": "When low latency is guaranteed.",
    "Analogy": "A live meeting.",
    "Pros": [
      "Simple logic"
    ],
    "Cons": [
      "Fails if network is slow"
    ]
  },
  "Asynchronous_Consensus": {
    "Category": "Consensus & Economics",
    "Meaning": "Consensus that works even if messages are delayed indefinitely.",
    "Where_it_is_used": "Global internet blockchains.",
    "When_it_is_used": "For maximum robustness.",
    "Analogy": "Email conversation.",
    "Pros": [
      "Resilient"
    ],
    "Cons": [
      "Complex to implement"
    ]
  },
  "Stake": {
    "Category": "Consensus & Economics",
    "Meaning": "Value locked up to participate in validation.",
    "Where_it_is_used": "PoS networks.",
    "When_it_is_used": "As a security bond.",
    "Analogy": "Security deposit.",
    "Pros": [
      "Incentivizes honesty"
    ],
    "Cons": [
      "Liquidity cost"
    ]
  },
  "Mining": {
    "Category": "Consensus & Economics",
    "Meaning": "The process of verifying transactions and adding them to the public ledger.",
    "Where_it_is_used": "PoW networks.",
    "When_it_is_used": "To find valid hashes.",
    "Analogy": "Digging for gold.",
    "Pros": [
      "Distribution mechanism"
    ],
    "Cons": [
      "Hardware arms race"
    ]
  },
  "Difficulty": {
    "Category": "Consensus & Economics",
    "Meaning": "A measure of how difficult it is to find a hash below a given target.",
    "Where_it_is_used": "PoW adjustment.",
    "When_it_is_used": "Every 2016 blocks (BTC) to keep time constant.",
    "Analogy": "Handicap in a game to keep it fair.",
    "Pros": [
      "Stabilizes block time"
    ],
    "Cons": [
      "None"
    ]
  },
  "Block_Reward": {
    "Category": "Consensus & Economics",
    "Meaning": "New coins given to the miner of a block.",
    "Where_it_is_used": "Coinbase transaction.",
    "When_it_is_used": "To incentivize security and distribute supply.",
    "Analogy": "Salary for the security guard.",
    "Pros": [
      "Bootstraps economy"
    ],
    "Cons": [
      "Inflation (usually)"
    ]
  },
  "Transaction_Fees": {
    "Category": "Consensus & Economics",
    "Meaning": "Fees paid to miners/validators to include a transaction.",
    "Where_it_is_used": "Every transaction.",
    "When_it_is_used": "To prioritize limited block space.",
    "Analogy": "Toll road fee.",
    "Pros": [
      "Spam prevention",
      "Long term security budget"
    ],
    "Cons": [
      "Can get expensive"
    ]
  },
  "Sybil_Attack": {
    "Category": "Security Constraints",
    "Meaning": "An attack where a single adversary controls many fake identities.",
    "Where_it_is_used": "P2P networks.",
    "When_it_is_used": "When attempting to sway a vote or swarm network.",
    "Analogy": "One person stuffing the ballot box with fake votes.",
    "Pros": [
      "(For attacker) Cheap influence"
    ],
    "Cons": [
      "Destabilizes trust"
    ]
  },
  "51%_Attack": {
    "Category": "Security Constraints",
    "Meaning": "An attack on a blockchain by a group of miners controlling more than 50% of the network's mining hashrate.",
    "Where_it_is_used": "PoW chains.",
    "When_it_is_used": "To double spend or halt transactions.",
    "Analogy": "A hostile takeover of the board.",
    "Pros": [
      "(For attacker) Control"
    ],
    "Cons": [
      "Destroys value of the asset"
    ]
  },
  "Double-Spending": {
    "Category": "Security Constraints",
    "Meaning": "The risk that a digital currency can be spent twice.",
    "Where_it_is_used": "The primary problem blockchain solves.",
    "When_it_is_used": "Maliciously sending funds to merchant and self simultaneously.",
    "Analogy": "Copy-pasting a digital file.",
    "Pros": [
      "(For attacker) Free money"
    ],
    "Cons": [
      "Undermines currency"
    ]
  },
  "Fork": {
    "Category": "Security Constraints",
    "Meaning": "A split in the blockchain network.",
    "Where_it_is_used": "Upgrades or disagreements.",
    "When_it_is_used": "When rules change.",
    "Analogy": "A fork in the road.",
    "Pros": [
      "Evolution",
      "Freedom to exit"
    ],
    "Cons": [
      "Split community"
    ]
  },
  "Hard_Fork": {
    "Category": "Security Constraints",
    "Meaning": "A radical change to a network's protocol that makes previously invalid blocks/transactions valid (or vice-versa). Non-backward compatible.",
    "Where_it_is_used": "Major upgrades.",
    "When_it_is_used": "Requires all nodes to upgrade.",
    "Analogy": "Playstation 5 vs Playstation 4 (can't play new games on old console).",
    "Pros": [
      "Clean break",
      "New features"
    ],
    "Cons": [
      "Risk of chain split"
    ]
  },
  "Soft_Fork": {
    "Category": "Security Constraints",
    "Meaning": "A backward-compatible upgrade to the protocol.",
    "Where_it_is_used": "Minor upgrades (SegWit).",
    "When_it_is_used": "Tightening rules.",
    "Analogy": "Vegetarian option (vegetarians can eat, meat eaters can too, just restricted).",
    "Pros": [
      "Less disruptive"
    ],
    "Cons": [
      "Can be complex to engineer"
    ]
  },
  "Centralization_Risk": {
    "Category": "Security Constraints",
    "Meaning": "The tendency for power to accumulate in fewer hands.",
    "Where_it_is_used": "Mining pools, large stake holders.",
    "When_it_is_used": "Assessing system health.",
    "Analogy": "Monopoly.",
    "Pros": [
      "Efficiency (sometimes)"
    ],
    "Cons": [
      "Censorship",
      "Failure points"
    ]
  },
  "Privacy_(vs_Security)": {
    "Category": "Security Constraints",
    "Meaning": "Privacy is keeping data secret; Security is keeping data integrity.",
    "Where_it_is_used": "Design tradeoffs.",
    "When_it_is_used": "Public vs Private chains.",
    "Analogy": "Validating a check (Security) vs hiding who wrote it (Privacy).",
    "Pros": [
      "Safety"
    ],
    "Cons": [
      "Audit difficulty"
    ]
  },
  "Transaction_Linking": {
    "Category": "Security Constraints",
    "Meaning": "Analyzing the history of transaction outputs to trace flow.",
    "Where_it_is_used": "Chain analysis.",
    "When_it_is_used": "Deanonymizing users.",
    "Analogy": "Following the money trail.",
    "Pros": [
      "Stopping crime"
    ],
    "Cons": [
      "Loss of privacy"
    ]
  },
  "Address_Clustering": {
    "Category": "Security Constraints",
    "Meaning": "Grouping addresses likely owned by the same entity.",
    "Where_it_is_used": "Forensics.",
    "When_it_is_used": "When input heuristics suggest common ownership.",
    "Analogy": "Grouping purchases from different cards to one person.",
    "Pros": [
      "Intelligence"
    ],
    "Cons": [
      "Privacy erosion"
    ]
  },
  "Scalability": {
    "Category": "Scalability & System Extensions",
    "Meaning": "The capacity to handle a growing amount of work.",
    "Where_it_is_used": "The Scalability Trilemma.",
    "When_it_is_used": "Discussing TPS (transactions per second).",
    "Analogy": "Adding lanes to a highway.",
    "Pros": [
      "More users"
    ],
    "Cons": [
      "Often hurts decentralization"
    ]
  },
  "Block_Size": {
    "Category": "Scalability & System Extensions",
    "Meaning": "The maximum data size of a block.",
    "Where_it_is_used": "Protocol rules.",
    "When_it_is_used": "Limiting throughput to ensure propagation.",
    "Analogy": "The size of the page in the ledger.",
    "Pros": [
      "Keeps nodes small (if small)"
    ],
    "Cons": [
      "Congestion (if small)"
    ]
  },
  "Layer_2_Solutions": {
    "Category": "Scalability & System Extensions",
    "Meaning": "Secondary framework or protocol built on top of an existing blockchain system.",
    "Where_it_is_used": "Lightning, Optimism, Arbitrum.",
    "When_it_is_used": "To enable high speed low cost transactions.",
    "Analogy": "Bar tab (settle later).",
    "Pros": [
      "Speed",
      "Cost"
    ],
    "Cons": [
      "Complexity"
    ]
  },
  "Sharding": {
    "Category": "Scalability & System Extensions",
    "Meaning": "Partitioning a database into smaller pieces.",
    "Where_it_is_used": "ETH 2.0 roadmap.",
    "When_it_is_used": "To process transactions in parallel.",
    "Analogy": "Checkout lines at a grocery store.",
    "Pros": [
      "Parallel processing"
    ],
    "Cons": [
      "Cross-shard communication"
    ]
  },
  "Interoperability": {
    "Category": "Scalability & System Extensions",
    "Meaning": "Ability of different computer systems to exchange and make use of information.",
    "Where_it_is_used": "Bridges, Polkadot, Cosmos.",
    "When_it_is_used": "Connecting siloed blockchains.",
    "Analogy": "Translating languages.",
    "Pros": [
      "Connected liquidity"
    ],
    "Cons": [
      "Bridge hacks"
    ]
  },
  "Smart_Contract": {
    "Category": "Programmability & Governance Layer",
    "Meaning": "Self-executing contract with the terms of the agreement between buyer and seller being directly written into lines of code.",
    "Where_it_is_used": "Ethereum, almost all dApps.",
    "When_it_is_used": "To automate trust.",
    "Analogy": "Vending machine.",
    "Pros": [
      "Automation",
      "Trustless"
    ],
    "Cons": [
      "Bugs are immutable"
    ]
  },
  "Decentralized_Application_(DApp)": {
    "Category": "Programmability & Governance Layer",
    "Meaning": "A digital application or program that runs on a decentralized network.",
    "Where_it_is_used": "DeFi, Games.",
    "When_it_is_used": "User interface for smart contracts.",
    "Analogy": "A website that talks to the blockchain instead of a bank database.",
    "Pros": [
      "Unstoppable",
      "Open access"
    ],
    "Cons": [
      "UX is hard"
    ]
  },
  "Decentralized_Autonomous_Organization_(DAO)": {
    "Category": "Programmability & Governance Layer",
    "Meaning": "An organization represented by rules encoded as a computer program that is transparent, controlled by the organization members and not influenced by a central government.",
    "Where_it_is_used": "Governance.",
    "When_it_is_used": "To manage shared treasuries.",
    "Analogy": "A co-op run by code.",
    "Pros": [
      "Global collaboration"
    ],
    "Cons": [
      "Voter apathy",
      "Governance attacks"
    ]
  },
  "Quantum_Computing_(Cryptographic_Threat)": {
    "Category": "Forward-Looking Security Constraint",
    "Meaning": "Computation using quantum phenomena which could theoretically break specific cryptographic algorithms (like ECC/RSA).",
    "Where_it_is_used": "Future threat modeling.",
    "When_it_is_used": "Designing long-term storage.",
    "Analogy": "A super-key that opens all current locks.",
    "Pros": [
      "Powerful computation"
    ],
    "Cons": [
      "Breaks current crypto"
    ]
  },
  "Quantum-Resistant_Cryptography_(Post-Quantum_Cryptography)": {
    "Category": "Forward-Looking Security Constraint",
    "Meaning": "Cryptographic algorithms that are thought to be secure against an attack by a quantum computer.",
    "Where_it_is_used": "Future upgrades.",
    "When_it_is_used": "To future-proof the chain.",
    "Analogy": "Quantum-proof locks.",
    "Pros": [
      "Security longevity"
    ],
    "Cons": [
      "Larger keys/signatures"
    ]
  }
}