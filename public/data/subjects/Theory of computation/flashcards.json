[
    {
        "front": "Theory of Computation",
        "back": "Study of what problems can be solved by algorithms (computability) and how efficiently (complexity), using formal models like automata and Turing machines.",
        "type": "term"
    },
    {
        "front": "Alphabet (Σ)",
        "back": "A finite, non-empty set of symbols used to form strings.",
        "type": "term"
    },
    {
        "front": "Symbol",
        "back": "An indivisible element of an alphabet (e.g., a, 0, 1).",
        "type": "term"
    },
    {
        "front": "String (word)",
        "back": "A finite sequence of symbols from Σ.",
        "type": "term"
    },
    {
        "front": "Empty string (ε)",
        "back": "The unique string of length 0.",
        "type": "term"
    },
    {
        "front": "Length of a string |w|",
        "back": "Number of symbols in w; |ε|=0.",
        "type": "term"
    },
    {
        "front": "Concatenation",
        "back": "Combining strings end-to-end: if x and y are strings, xy is their concatenation and |xy|=|x|+|y|.",
        "type": "term"
    },
    {
        "front": "Star closure (Σ*)",
        "back": "Set of all finite strings over Σ, including ε.",
        "type": "term"
    },
    {
        "front": "Grammar G=(V,T,P,S)",
        "back": "V: variables (nonterminals), T: terminals, P: productions, S: start symbol.",
        "type": "term"
    },
    {
        "front": "Deterministic Finite Automaton (DFA)",
        "back": "A 5-tuple (Q,Σ,δ,q0,F) with δ:Q×Σ→Q (exactly one next state).",
        "type": "term"
    },
    {
        "front": "Nondeterministic Finite Automaton (NFA)",
        "back": "A 5-tuple (Q,Σ,δ,q0,F) with δ:Q×(Σ∪{ε})→2^Q (can branch, can use ε-moves).",
        "type": "term"
    },
    {
        "front": "ε-transition (epsilon move)",
        "back": "A transition that changes state without consuming an input symbol.",
        "type": "term"
    },
    {
        "front": "Regular language",
        "back": "A language is regular iff it is recognized by a DFA (equivalently by an NFA/RE/regular grammar).",
        "type": "term"
    },
    {
        "front": "Regular expression (RE) operations",
        "back": "Union (| or ∪), concatenation, and Kleene star (*).",
        "type": "term"
    },
    {
        "front": "Arden’s Theorem",
        "back": "If X = AX ∪ B and ε ∉ A, then X = A*B.",
        "type": "term"
    },
    {
        "front": "Regular grammar (RG)",
        "back": "A grammar that is entirely right-linear or entirely left-linear; it generates a regular language.",
        "type": "term"
    },
    {
        "front": "Closure properties of regular languages",
        "back": "Closed under union, intersection, concatenation, Kleene star, and complement.",
        "type": "term"
    },
    {
        "front": "Pumping Lemma (Regular Languages)",
        "back": "If L is regular, ∃p such that any s∈L with |s|≥p can be written s=xyz with |xy|≤p, |y|>0, and ∀i≥0, xy^iz∈L.",
        "type": "term"
    },
    {
        "front": "Context-Free Language (CFL)",
        "back": "A language generated by a context-free grammar (CFG); includes all regular languages.",
        "type": "term"
    },
    {
        "front": "Pushdown Automaton (PDA)",
        "back": "A 7-tuple (Q,Σ,Γ,δ,q0,Z0,F); an NFA plus a stack (Γ) used to recognize CFLs.",
        "type": "term"
    },
    {
        "front": "If Σ={0,1}, is the string \"01010\" in Σ*?",
        "back": "Yes. It uses only symbols 0 and 1, so it is a valid finite binary string.",
        "type": "question"
    },
    {
        "front": "If Σ={a,b}, is \"abca\" in Σ*? Why?",
        "back": "No. It contains 'c', which is not in Σ, so it cannot be in Σ*.",
        "type": "question"
    },
    {
        "front": "Compute |xy| if |x|=3 and |y|=5.",
        "back": "8.",
        "type": "question"
    },
    {
        "front": "True or False: ε equals ∅.",
        "back": "False. ε is a string; ∅ is a language (the empty set of strings).",
        "type": "question"
    },
    {
        "front": "What is the tuple definition of a DFA?",
        "back": "(Q, Σ, δ, q0, F).",
        "type": "question"
    },
    {
        "front": "What is the key difference between DFA and NFA acceptance?",
        "back": "DFA: one computation path; accept if that path ends in F. NFA: many possible paths; accept if at least one path ends in F.",
        "type": "question"
    },
    {
        "front": "In subset construction (NFA→DFA), what does a DFA state represent?",
        "back": "A set (subset) of NFA states reachable after reading the same input prefix.",
        "type": "question"
    },
    {
        "front": "A DFA recognizes strings ending with \"11\" over {0,1}. Does it accept \"1011\"?",
        "back": "Yes. The last two symbols are 11.",
        "type": "question"
    },
    {
        "front": "Same DFA (ends with \"11\"): does it accept \"1110\"?",
        "back": "No. It ends with 10, not 11.",
        "type": "question"
    },
    {
        "front": "When minimizing a DFA, what does it mean if two states are distinguishable?",
        "back": "There exists some string w such that starting from one state leads to acceptance and starting from the other leads to rejection.",
        "type": "question"
    },
    {
        "front": "Give a regular expression for binary strings ending with 11.",
        "back": "(0|1)*11",
        "type": "question"
    },
    {
        "front": "Give a regular expression for strings over {a,b} that start with a and end with a, with any number of b’s in between.",
        "back": "a(b*)a",
        "type": "question"
    },
    {
        "front": "Which RE operation is commutative: union or concatenation?",
        "back": "Union is commutative; concatenation is not.",
        "type": "question"
    },
    {
        "front": "Use Arden’s Theorem to solve X = aX ∪ b (assume ε ∉ a).",
        "back": "X = a*b.",
        "type": "question"
    },
    {
        "front": "Is a right-linear grammar allowed to have a production A→Ba?",
        "back": "No. Right-linear requires the (optional) variable to be at the right end: A→aB or A→a (not Ba).",
        "type": "question"
    },
    {
        "front": "If L1 and L2 are regular, is L1 ∩ L2 regular?",
        "back": "Yes. Regular languages are closed under intersection (e.g., via product DFA construction).",
        "type": "question"
    },
    {
        "front": "What’s the standard goal of the Pumping Lemma for regular languages in exams?",
        "back": "To prove a language is NOT regular by contradiction (assume regular, choose a long string, show pumping breaks membership).",
        "type": "question"
    },
    {
        "front": "In the Pumping Lemma, who effectively chooses the split s=xyz?",
        "back": "The lemma guarantees some split exists; in a non-regularity proof you must handle all valid splits (adversarial choice).",
        "type": "question"
    },
    {
        "front": "CFL closure: Are CFLs always closed under intersection and complement?",
        "back": "No. CFLs are closed under union/concatenation/star, but intersection and complement are not guaranteed.",
        "type": "question"
    },
    {
        "front": "What additional memory does a PDA have that a DFA does not, and what is its access pattern?",
        "back": "A stack with LIFO access (push/pop at the top).",
        "type": "question"
    }
]